diff -urN q-e-qe-5.3/install/configure q-e-qe-5.3-patched/install/configure
--- q-e-qe-5.3/install/configure	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/install/configure	2019-05-07 17:02:08.433764892 +0200
@@ -682,6 +682,7 @@
 GREP
 CPP
 cflags
+cflags_c99
 cc
 ac_ct_CC
 CPPFLAGS
@@ -1900,6 +1901,7 @@
 env_cc=$CC         # C compiler (must be in the execution path)
 cpp=$CPP           # C preprocessor (as above)
 cflags=$CFLAGS     # Flags for C compiler
+cflags_c99=$C99FLAGS     # Flags for C compiler
 cppflags=$CPPFLAGS # Flags for C preprocessor
 dflags=$DFLAGS     # Fortran file preprocessing options, e.g. -D__DEFINE_THIS
 iflags=$IFLAGS     # Location of include files - shouldn't be needed
@@ -4040,6 +4042,7 @@
 
 # tentative C and loader flags, good for many cases
 try_cflags="-O3"
+try_c99flags="-std=c99"
 c_ldflags=""
 try_cpp="cpp"
 
@@ -4090,6 +4093,8 @@
 if test "$cflags" = "" ; then cflags=$try_cflags ; fi
 echo setting CFLAGS... $cflags
 
+#this is just going to be set.  Whatevs.
+cflags_c99=$try_c99flags 
 # compilation flags for all subsequent tests
 test_cflags="`echo $cflags | sed 's/\$([^)]*)//g'`"
 
diff -urN q-e-qe-5.3/install/make.sys.in q-e-qe-5.3-patched/install/make.sys.in
--- q-e-qe-5.3/install/make.sys.in	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/install/make.sys.in	2019-05-07 17:02:08.433764892 +0200
@@ -77,9 +77,14 @@
 # C flags must include DFLAGS and IFLAGS
 # F90 flags must include MODFLAGS, IFLAGS, and FDFLAGS with appropriate syntax
 
-CFLAGS         = @cflags@ $(DFLAGS) $(IFLAGS)
-F90FLAGS       = @f90flags@ @pre_fdflags@$(FDFLAGS) $(IFLAGS) $(MODFLAGS)
-FFLAGS         = @fflags@
+CFLAGS         = -fPIC @cflags@ $(DFLAGS) $(IFLAGS)
+F90FLAGS       = -fPIC @f90flags@ @pre_fdflags@$(FDFLAGS) $(IFLAGS) $(MODFLAGS)
+FFLAGS         = -fPIC @fflags@
+
+# compiler flags with C99 standard 
+# Needed for HDF5 and for compiling the shared library libpwinterface.so
+# Compiler appropraite -shared flag is required.  
+CFLAGS_C99     = @cflags_c99@ -shared
 
 # compiler flags without optimization for fortran-77
 # the latter is NEEDED to properly compile dlamch.f, used by lapack
@@ -98,6 +103,9 @@
 LDFLAGS        = @ldflags@
 LD_LIBS        = @ld_libs@
 
+#C++ linker for shared library. 
+LDCPP          = ${CC}
+LDCPP_LIBS     =             #make sure equivalent of -lifport and -lifcore are included here.  
 # External Libraries (if any) : blas, lapack, fft, MPI
 
 # If you have nothing better, use the local copy :
@@ -148,7 +156,7 @@
 FLIB_TARGETS   = all
 
 LIBOBJS        = ../flib/ptools.a ../flib/flib.a ../clib/clib.a ../iotk/src/libiotk.a 
-LIBS           = $(SCALAPACK_LIBS) $(LAPACK_LIBS) $(FFT_LIBS) $(BLAS_LIBS) $(MPI_LIBS) $(MASS_LIBS) $(LD_LIBS)
+LIBS           = $(SCALAPACK_LIBS) $(LAPACK_LIBS) $(FFT_LIBS) $(BLAS_LIBS) $(MPI_LIBS) $(MASS_LIBS) $(LD_LIBS) $(LDCPP_LIBS) 
 
 # wget or curl - useful to download from network
 WGET = @wget@
diff -urN q-e-qe-5.3/Modules/mp_bands.f90 q-e-qe-5.3-patched/Modules/mp_bands.f90
--- q-e-qe-5.3/Modules/mp_bands.f90	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/Modules/mp_bands.f90	2019-06-13 17:02:04.234141984 +0200
@@ -78,7 +78,7 @@
     !
     ! ... set index of processor within the image ( 0 : nproc_image - 1 )
     !
-    me_bgrp    = MOD( parent_mype, nproc_bgrp )
+!!!!!    me_bgrp    = MOD( parent_mype, nproc_bgrp )
     !
     CALL mp_barrier( parent_comm )
     !
diff -urN q-e-qe-5.3/Modules/mp_base.f90 q-e-qe-5.3-patched/Modules/mp_base.f90
--- q-e-qe-5.3/Modules/mp_base.f90	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/Modules/mp_base.f90	2019-06-13 16:40:45.949236551 +0200
@@ -34,8 +34,9 @@
    INTEGER, INTENT(IN) :: gid
 #if defined __MPI && defined __USE_BARRIER
    INTEGER :: ierr
-   CALL mpi_barrier( gid, ierr )
-   IF( ierr /= 0 ) CALL errore( 'mp_synchronize ', ' error in mpi_barrier ', ierr )
+   ! WARNING, I AM SHUTTING EVERYTHING DOWN HERE FOR THE INTERFACE TESTING
+   !CALL mpi_barrier( gid, ierr )
+   !IF( ierr /= 0 ) CALL errore( 'mp_synchronize ', ' error in mpi_barrier ', ierr )
 #endif
    RETURN
 END SUBROUTINE mp_synchronize
@@ -107,7 +108,6 @@
 #endif
 
         IF( n <= 0 ) GO TO 1
-
 #if defined __USE_BARRIER
         CALL mp_synchronize( gid )
 #endif
diff -urN q-e-qe-5.3/PW/src/input.f90 q-e-qe-5.3-patched/PW/src/input.f90
--- q-e-qe-5.3/PW/src/input.f90	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/input.f90	2019-07-11 14:48:36.017902770 +0200
@@ -1333,7 +1333,8 @@
   !
 
   ALLOCATE( ityp( nat_ ) )
-  ALLOCATE( tau(    3, nat_ ) )
+  write(*,*)"Allocating tau now!"
+  if(.not.allocated(tau))ALLOCATE( tau(    3, nat_ ) )  
   ALLOCATE( force(  3, nat_ ) )
   ALLOCATE( if_pos( 3, nat_ ) )
   ALLOCATE( extfor( 3, nat_ ) )
Binary files q-e-qe-5.3/PW/src/intf and q-e-qe-5.3-patched/PW/src/intf differ
Binary files q-e-qe-5.3/PW/src/libpwinterface.so and q-e-qe-5.3-patched/PW/src/libpwinterface.so differ
diff -urN q-e-qe-5.3/PW/src/Makefile q-e-qe-5.3-patched/PW/src/Makefile
--- q-e-qe-5.3/PW/src/Makefile	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/Makefile	2019-07-11 14:20:20.967343727 +0200
@@ -166,6 +166,7 @@
 pw2blip.o \
 pw2casino.o \
 pw2casino_write.o \
+pwinterfacemod.o \
 qvan2.o \
 rcgdiagg.o \
 rdiagh.o \
@@ -246,13 +247,20 @@
 wannier_enrg.o \
 wyckoff.o       
 
+PWINTERFACELIBS= \
+pwinterfacemod.o \
+pwlib_getinfo.o \
+pwlib_init.o \
+pwlib_scf.o \
+pwlib_setinfo.o
+
 QEMODS=../../Modules/libqemod.a ../../FFTXlib/libqefft.a
 
 TLDEPS=bindir mods libs liblapack libblas
 
 LIBOBJS	= ../../flib/ptools.a ../../flib/flib.a ../../clib/clib.a ../../iotk/src/libiotk.a
 
-all : tldeps pw.x manypw.x generate_vdW_kernel_table.x generate_rVV10_kernel_table.x
+all : tldeps pw.x manypw.x generate_vdW_kernel_table.x generate_rVV10_kernel_table.x libpwinterface.so
 
 pw.x : $(PWOBJS) libpw.a $(LIBOBJS) $(QEMODS)
 	$(LD) $(LDFLAGS) -o $@ \
@@ -268,6 +276,19 @@
 	$(AR) $(ARFLAGS) $@ $?
 	$(RANLIB) $@
 
+libpwinterface.so :  $(PWINTERFACELIBS) libpw.a $(LIBOBJS) $(QEMODS)
+	$(LDCPP) $(CFLAGS_C99) -o $@ \
+	   $(PWINTERFACELIBS) libpw.a $(QEMODS) $(LIBOBJS) $(LIBS)
+#libpwinterface.a :  $(LIBOBJS) $(QEMODS)
+#	$(AR) -x ../../Modules/libqemod.a
+#	$(AR) -x ../../FFTXlib/libqefft.a
+#	$(AR) -x ../../flib/ptools.a
+#	$(AR) -x ../../flib/flib.a
+#	$(AR) -x ../../clib/clib.a
+#	$(AR) -x ../../iotk/src/libiotk.a
+#	$(AR) $(ARFLAGS) libpwinterface.a *.o
+#	$(RANLIB) libpwinterface.a
+ 
 tldeps :
 	if test -n "$(TLDEPS)" ; then \
 	( cd ../.. ; $(MAKE) $(TLDEPS) || exit 1 ) ; fi
diff -urN q-e-qe-5.3/PW/src/pwinterfacemod.f90 q-e-qe-5.3-patched/PW/src/pwinterfacemod.f90
--- q-e-qe-5.3/PW/src/pwinterfacemod.f90	1970-01-01 01:00:00.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/pwinterfacemod.f90	2019-07-11 14:42:30.387398902 +0200
@@ -0,0 +1,274 @@
+!
+! Copyright (C) 2001-2013 Quantum ESPRESSO group
+! This file is distributed under the terms of the
+! GNU General Public License. See the file `License'
+! in the root directory of the present distribution,
+! or http://www.gnu.org/copyleft/gpl.txt .
+!
+!----------------------------------------------------------------------------
+MODULE pwinterfacemod
+  !----------------------------------------------------------------------------
+  !
+  ! ... This ``interface" holds temporary data like gvector maps and data
+  ! ... partitioning among mpi processes. 
+  ! ... performs
+  USE klist,            ONLY : nelec,nelup,neldw,nkstot,nks, xk
+  USE wvfct,            ONLY : nbnd, igk, g2kin, npw, ecutwfc, npw, npwx
+  USE gvect,            ONLY : ngm, g
+  USE cell_base,        ONLY : tpiba2, at
+  USE io_files,         ONLY : nwordwfc, iunwfc
+  USE wavefunctions_module, ONLY : evc
+  USE fft_base,             ONLY : dffts
+  USE mp_pools, ONLY: inter_pool_comm, intra_pool_comm, nproc_pool, me_pool
+  !
+  IMPLICIT NONE
+  SAVE
+
+  INTEGER :: mesh(3)
+  INTEGER, ALLOCATABLE :: indx(:), igtog(:), igtomin(:) 
+  INTEGER :: current_kpt=-1 !
+
+  INTEGER :: ngtot   !the total number of k+g vectors < ecut on a process.  
+  INTEGER :: ngtot_g !the total number of k+g vectors < ecut on ALL processes.
+  INTEGER :: npw_g   !
+  INTEGER :: npwx_g 
+  LOGICAL :: gvec_set=.false. !this flag determines if gvector maps have been
+                              !initialized.
+
+  INTEGER, ALLOCATABLE :: ng_proc(:), ng_disp(:)
+  !ng_proc:  1:nproc array with ng_proc(i)=ngtot, where i is the rank of a
+  !process.
+  
+  !ng_disp:  1:nproc array.  Cumulative sum of ng_proc.  ng_disp(1)=0.
+  !          this is for MPI_Gatherv, when number of gvectors owned by process
+  !          are not the same.
+
+  PUBLIC  :: getwfn_info, get_gvecs, get_band
+  PRIVATE :: create_g_maps, get_bands_at_kpt 
+  
+ CONTAINS
+
+  SUBROUTINE getwfn_info(nbands_, nktot_, nkloc_, mesh_, ngtot_, npw_, npwx_)
+      USE klist,            ONLY : nelec,nelup,neldw,nkstot,nks, xk
+      USE wvfct,            ONLY : nbnd, igk, g2kin, npw, ecutwfc, npw, npwx
+      USE gvect,            ONLY : ngm, g
+      USE cell_base,        ONLY : tpiba2
+      USE io_files,         ONLY : nwordwfc, iunwfc
+      USE fft_base,         ONLY : dffts
+      USE mp_world,         ONLY : world_comm
+      USE mp,               ONLY : mp_sum, mp_rank, mp_barrier
+      USE io_global, ONLY: stdout
+     INTEGER, INTENT(OUT) :: nbands_, nktot_, nkloc_, ngtot_, npw_, npwx_
+     INTEGER, INTENT(OUT) :: mesh_(3)
+
+     nbands_=nbnd
+     nktot_=nkstot
+     nkloc_=nks
+!     WRITE(stdout,*) 'rank = ',mp_rank(world_comm)
+!     WRITE(stdout,*) 'nbands = ',nbands_
+!     WRITE(stdout,*) 'nktot = ',nktot_
+!     WRITE(stdout,*) 'nkloc = ',nkloc_
+!     WRITE(stdout,*) 'gvec_set = ',gvec_set
+!     WRITE(stdout,*) 'mpi_comm_world = ',world_comm
+!     WRITE(stdout,*) 'inter_pool_comm = ',inter_pool_comm
+!     WRITE(stdout,*) 'intra_pool_comm = ',intra_pool_comm 
+     call mp_barrier(world_comm)
+!     call flush_unit(stdout)
+     IF( gvec_set .eqv. .false. ) CALL create_g_maps()
+     mesh_(1) = mesh(1)
+     mesh_(2) = mesh(2)
+     mesh_(3) = mesh(3)
+
+     ngtot_g=ngtot
+     npw_g=npw
+     npwx_g=npwx
+    
+     !sum the local ngtot, npw's, and npwx's over all processes.  results stored
+     !in X_g.
+     CALL mp_sum(ngtot_g,intra_pool_comm) 
+     CALL mp_sum(npw_g, intra_pool_comm)
+     CALL mp_sum(npwx_g, intra_pool_comm)
+
+     ngtot_=ngtot_g  
+     npw_=npw_g
+     npwx_=npwx_g
+
+  END SUBROUTINE getwfn_info
+
+ 
+ SUBROUTINE create_g_maps()
+   USE mp_world,         ONLY : world_comm
+   USE io_global, ONLY: stdout, ionode, ionode_id
+   USE mp,        ONLY: mp_gather, mp_barrier, mp_bcast
+   INTEGER :: ik, ig
+   ALLOCATE (indx (4*npwx) )
+   ALLOCATE (igtog (4*npwx) )
+   ALLOCATE (igtomin(4*npwx) )
+    
+   ALLOCATE(ng_proc(nproc_pool))
+   ALLOCATE(ng_disp(nproc_pool))
+   
+   indx=0
+   igtog=0
+   igtomin=0
+
+   ng_proc=0
+   ng_disp=0
+
+   mesh(1) = dffts%nr1
+   mesh(2) = dffts%nr2
+   mesh(3) = dffts%nr3 
+
+   
+   !Taken from pw2qmcpack.  This creates a map from the gvector list to energy sorted k+g vectors in
+   !the array igk(:).  
+   !indx notes which gvectors are used among all kvectors.
+   !
+   !NOTE:  MAPS & gvecs are local to this mpiprocess.  gvectors are distributed before we
+   !get here.  
+   DO ik = 1, nkstot
+      CALL gk_sort (xk (1, ik), ngm, g, ecutwfc / tpiba2, npw, igk, g2kin)
+      DO ig =1, npw
+         IF( igk(ig) > 4*npwx ) & 
+              CALL errore ('pwinterface','increase allocation of index', ig)
+         indx( igk(ig) ) = 1 
+      ENDDO
+   ENDDO
+    
+   ngtot = 0
+   
+   DO ig = 1, 4*npwx
+     IF( indx(ig) == 1 ) THEN
+       ngtot = ngtot + 1          
+       igtog(ngtot) = ig   !in k-collected gvector list, find where ig lies in it.  
+       igtomin(ig) = ngtot
+     ENDIF
+   ENDDO 
+   
+   gvec_set=.true.
+!   WRITE(*,*) "calling mp_gather in create_g_maps"
+!   WRITE(*,*) "ngtot=",ngtot," ng_proc=",ng_proc," ionode_id=",ionode_id," intra_pool_comm=",intra_pool_comm 
+   CALL mp_gather(ngtot, ng_proc, ionode_id, intra_pool_comm) !collect all local
+   CALL mp_bcast(ng_proc, ionode_id, intra_pool_comm)         !broadcast ng_proc to all processes
+   !Set up the displacement vector for gatherv.  
+   ng_disp(0)=0         
+   DO ik=2,nproc_pool
+     ng_disp(ik)=ng_disp(ik-1)+ng_proc(ik-1)
+   ENDDO
+
+ END SUBROUTINE create_g_maps 
+
+ SUBROUTINE get_gvecs(gvecs_)
+   USE io_global, ONLY: stdout, ionode, ionode_id
+   USE mp,        ONLY: mp_gather, mp_bcast, mp_barrier
+   INTEGER :: disp(nproc_pool), proc_dat(nproc_pool)
+   INTEGER :: ig, ig_c
+   INTEGER :: gvecs_(3,ngtot_g)
+   INTEGER :: gvecs_local(3,ngtot)
+
+   !We have local versions of ng_disp and ng_proc, except modified
+   ! to account for 3xn vectors being sent.  Multiply ng_proc and disp by 3
+   ! to handle this.     
+   disp(1:nproc_pool) = 3*ng_disp(1:nproc_pool)
+   proc_dat(1:nproc_pool)=3*ng_proc(1:nproc_pool)
+   IF (gvec_set .eqv. .false.) CALL create_g_maps()
+ 
+   DO ig=1, ngtot
+     ig_c =igtog(ig)
+     gvecs_local(1,ig)=NINT(at(1,1)*g(1,ig_c)+at(2,1)*g(2,ig_c)+at(3,1)*g(3,ig_c))
+     gvecs_local(2,ig)=NINT(at(1,2)*g(1,ig_c)+at(2,2)*g(2,ig_c)+at(3,2)*g(3,ig_c))
+     gvecs_local(3,ig)=NINT(at(1,3)*g(1,ig_c)+at(2,3)*g(2,ig_c)+at(3,3)*g(3,ig_c))
+    ENDDO
+
+  CALL mp_gather(gvecs_local(1:3,:), gvecs_(1:3,:), ng_proc, ng_disp, ionode_id, intra_pool_comm)
+  CALL mp_bcast(gvecs_, ionode_id, intra_pool_comm)  !again, collect gvecs to ionode, and then broadcast to all 
+
+ END SUBROUTINE get_gvecs
+
+ SUBROUTINE get_bands_at_kpt(ik)
+   USE wavefunctions_module, ONLY : evc
+   USE cell_base, ONLY: omega, alat, tpiba2, at, bg
+   USE gvect, ONLY: ngm, g
+   USE gvecs, ONLY : nls, nlsm  
+   USE klist , ONLY: nks, nelec, nelup, neldw, wk, xk, nkstot
+   USE wvfct, ONLY: npw, npwx, nbnd, igk, g2kin, wg, et, ecutwfc
+   USE buffers,              ONLY : get_buffer
+   USE io_global, ONLY: stdout, ionode, ionode_id
+
+   INTEGER :: ik
+
+   CALL gk_sort (xk (1:3, ik), ngm, g, ecutwfc / tpiba2, npw, igk, g2kin)
+   IF(nks>1) CALL get_buffer (evc, nwordwfc, iunwfc, ik)
+   
+ END SUBROUTINE get_bands_at_kpt
+
+ SUBROUTINE get_band(cg_, ibnd_, ik_)
+   USE wavefunctions_module, ONLY : evc
+   USE io_global, ONLY: stdout, ionode, ionode_id
+   USE mp,        ONLY: mp_gather, mp_bcast
+
+   COMPLEX*16, INTENT(OUT) :: cg_(ngtot_g) ! plane wave coefficients that are returned.
+   COMPLEX*16 :: cg_local(ngtot)           ! the local pw coefficients corresponding to local gvecs. 
+   INTEGER, INTENT(IN) :: ik_, ibnd_       ! kpoint id and band number respectively.  
+!   WRITE(*,*) "pwinterfacemod::get_band(cg, ibnd, ik)"
+!   WRITE(*,*) "   ibnd=",ibnd_, " ik=", ik_
+   
+   IF (gvec_set .eqv. .false.) CALL create_g_maps()
+   
+   IF (ik_ /= current_kpt) THEN            !only read and grab PW data if it hasn't be done for this kpoint already.  
+     CALL get_bands_at_kpt(ik_)            !  e.g. you have to read all the bands at a kpoint
+     current_kpt = ik_
+   ENDIF
+ 
+   cg_local(:)=(0.d0,0.d0)
+   cg_local(igtomin(igk(1:npw))) = evc(1:npw,ibnd_)
+    
+   CALL mp_gather(cg_local, cg_,ng_proc, ng_disp, ionode_id, intra_pool_comm) 
+   CALL mp_bcast(cg_, ionode_id, intra_pool_comm)
+
+ END SUBROUTINE get_band
+
+ SUBROUTINE get_atom_pos(R)
+     USE ions_base,       ONLY : nat, tau
+     USE cell_base,       ONLY : alat
+     USE kinds,             ONLY:  DP     
+      !
+     REAL(DP), INTENT(OUT) :: R(3,nat)
+      !
+      R     = tau*alat
+
+ END SUBROUTINE get_atom_pos
+
+
+ SUBROUTINE set_atom_pos(R)
+     USE ions_base,       ONLY : nat, tau
+     USE cell_base,       ONLY : alat
+     USE kinds,             ONLY:  DP     
+      !
+     REAL(DP), INTENT(IN) :: R(3,nat)
+      !
+     write(*,*)'is this it?'
+      tau     = R/alat
+     write(*,*)'nope'
+
+ END SUBROUTINE set_atom_pos
+
+
+ SUBROUTINE get_atom_types(ityp_)
+     USE ions_base,       ONLY : nat, ityp
+      !
+     INTEGER, INTENT(OUT) :: ityp_(nat)
+     !
+     ityp_=ityp
+ END SUBROUTINE get_atom_types
+
+ SUBROUTINE set_atom_types(ityp_)
+     USE ions_base,       ONLY : nat, ityp
+      !
+     INTEGER, INTENT(IN) :: ityp_(nat)
+     !
+     ityp=ityp_
+   
+ END SUBROUTINE set_atom_types
+
+END MODULE pwinterfacemod
diff -urN q-e-qe-5.3/PW/src/pwlib_getinfo.f90 q-e-qe-5.3-patched/PW/src/pwlib_getinfo.f90
--- q-e-qe-5.3/PW/src/pwlib_getinfo.f90	1970-01-01 01:00:00.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/pwlib_getinfo.f90	2019-05-16 15:36:43.473007785 +0200
@@ -0,0 +1,245 @@
+    !
+    !------------------------------------------------------------------------
+    !SUBROUTINE pwlib_getinfo(nat_,charge_,nup_,ndown_,nktot_,nkloc_,box_,  &
+     ! kpts_,wkp_,ngrid_,nbds_,ngridx_)
+    SUBROUTINE pwlib_getinfo(nat_,charge_,nup_,ndown_,nkloc_,box_,nktot_,kpts_)
+      !------------------------------------------------------------------------
+      !
+      USE ions_base,        ONLY : nat, nsp
+      USE klist,            ONLY : xk,wk,nelec,nelup,neldw,nkstot,nks,tot_charge 
+      USE wvfct,            ONLY : nbnd  
+      USE fft_base,         ONLY : dffts
+      USE cell_base,        ONLY : at,alat,tpiba
+     USE kinds,             ONLY:  DP     
+      !
+      IMPLICIT NONE
+      !
+      !
+      INTEGER, INTENT(OUT) :: nat_,charge_,nup_,ndown_,nktot_,nkloc_
+      INTEGER :: jk
+      REAL(DP), INTENT(OUT) :: box_(3,3), kpts_(3,nks) 
+      !
+      nat_ = nat 
+      charge_ = tot_charge 
+      nup_ = NINT(nelup)      
+      ndown_ = NINT(neldw)
+      nktot_ = nkstot
+      nkloc_ = nks
+      box_ = at*alat
+
+      kpts_(1:3,1:nks) = xk(1:3,1:nks)*tpiba
+      
+      ! 
+    END SUBROUTINE pwlib_getinfo
+    !
+   SUBROUTINE pwlib_getbox_data(box_)
+     USE cell_base,       ONLY : at, alat
+     USE kinds,             ONLY:  DP     
+
+     IMPLICIT NONE
+     REAL(DP), INTENT(OUT) :: box_(3,3)
+     
+     box_=at*alat 
+
+   END SUBROUTINE pwlib_getbox_data
+
+   
+
+   SUBROUTINE pwlib_getatom_info(nat_, nsp_)
+      !------------------------------------------------------------------------
+      !
+      USE ions_base,       ONLY : nat, nsp
+      !
+      INTEGER, INTENT(OUT) :: nat_, nsp_
+      !
+      nat_ = nat
+      nsp_ = nsp
+
+   END SUBROUTINE pwlib_getatom_info
+
+!! Get/Set Routines for ion data.  
+   !Returns R in bohr.  
+   SUBROUTINE pwlib_getatom_data(R, ityp_)
+      !------------------------------------------------------------------------
+      !
+      USE ions_base,       ONLY : nat, nsp, ityp, tau
+      USE cell_base,       ONLY : alat
+      USE kinds,             ONLY:  DP     
+      USE pwinterfacemod,  ONLY : get_atom_pos, get_atom_types
+       !
+      REAL(DP), INTENT(OUT) :: R(3,nat)
+      INTEGER, INTENT(OUT) :: ityp_(nat)
+      !
+      CALL get_atom_pos(R)
+      CALL get_atom_types(ityp_)
+   END SUBROUTINE pwlib_getatom_data
+
+   SUBROUTINE pwlib_getatom_pos(R)
+     USE pwinterfacemod, ONLY : get_atom_pos
+     USE ions_base,  ONLY : nat
+     USE kinds,             ONLY:  DP
+
+     REAL(DP), INTENT(OUT) :: R(3,nat)
+
+     CALL get_atom_pos(R)
+   END SUBROUTINE pwlib_getatom_pos
+
+
+   SUBROUTINE pwlib_getatom_types(ityp_)
+     USE pwinterfacemod, ONLY : get_atom_types
+     USE ions_base,  ONLY : nat
+
+     INTEGER, INTENT(OUT) :: ityp_(nat)
+
+     CALL get_atom_types(ityp_)
+
+   END SUBROUTINE pwlib_getatom_types
+!   SUBROUTINE pwlib_setatom_data(R,ityp, nat_, nsp_)
+!      !------------------------------------------------------------------------
+!      USE ions_base,      ONLY nat, 
+!   END SUBROUTINE pwlib_setatom_data
+    ! anums=atomic numbers, vcharge=valence charges, masses=ion masses in amu,
+    ! names are element names.  
+   SUBROUTINE pwlib_getspecies_data(anums, vcharge, masses, names)
+      !------------------------------------------------------------------------
+      !
+      USE ions_base,       ONLY : nsp, atm, zv, amass
+     USE kinds,             ONLY:  DP     
+      !
+      INTEGER, EXTERNAL :: atomic_number
+      INTEGER, INTENT(OUT) :: anums(nsp), vcharge(nsp)
+      REAL(DP), INTENT(OUT) :: masses(nsp)
+      CHARACTER(LEN=3), INTENT(OUT) :: names(nsp)
+      INTEGER :: ik
+      !
+      do ik=1,nsp
+        anums(ik)=atomic_number(TRIM(atm(ik)))
+      end do 
+
+      vcharge = zv
+      masses=amass
+      names=atm
+      
+      write(*,*)'asdasda', zv(1), amass(1), anums(1),names(1)
+   END SUBROUTINE pwlib_getspecies_data
+
+  SUBROUTINE pwlib_getelectron_info(nelec_, nup_, ndown_, nktot_, nkloc_)
+      USE klist,            ONLY : nelec,nelup,neldw 
+   !   USE fft_base,         ONLY : dffts
+        
+      INTEGER, INTENT(OUT) :: nelec_, nup_, ndown_
+      
+      nelec_  = nelec 
+      nup_    = nelup
+      ndown_  = neldw
+      
+  END SUBROUTINE pwlib_getelectron_info
+ 
+  SUBROUTINE pwlib_getwfn_info(nbands_, nktot_, nkloc_, mesh_, ngtot_, npw_, npwx_)
+     USE pwinterfacemod,    ONLY : getwfn_info 
+     USE mp,                ONLY : mp_rank 
+           USE mp_world,         ONLY : world_comm
+      USE io_global, ONLY: stdout
+
+     INTEGER, INTENT(OUT) :: nbands_, nktot_, nkloc_, ngtot_, npw_, npwx_
+     INTEGER, INTENT(OUT) :: mesh_(3)
+     
+
+     WRITE(*,*) 'b4 getwfn_info...'
+          WRITE(stdout,*) 'rank = ',mp_rank(world_comm)
+
+     CALL getwfn_info(nbands_, nktot_, nkloc_, mesh_, ngtot_, npw_, npwx_)
+    
+     
+  END SUBROUTINE pwlib_getwfn_info
+
+  SUBROUTINE pwlib_getwfn_gvecs(gvecs_)
+   USE pwinterfacemod,    ONLY: ngtot, igtog, get_gvecs
+
+   INTEGER :: gvecs_(3,ngtot)
+ 
+   CALL get_gvecs(gvecs_)
+ 
+  END SUBROUTINE pwlib_getwfn_gvecs
+
+!  SUBROUTINE pwlib_testcomplex(test_)
+!      USE pwinterfacemod,   ONLY  : x
+!     COMPLEX*16, INTENT(OUT) :: test_(3)
+!     COMPLEX*16 :: doop(3)
+!
+!     doop(1)=cmplx(1,-1)
+!     doop(2)=cmplx(2,-2)
+!     doop(3)=cmplx(3,-3)
+!
+!     test_=doop
+!    
+!      WRITE(*,*) "X from module is given by ", x
+!
+!  END SUBROUTINE pwlib_testcomplex
+
+  SUBROUTINE pwlib_getwfn_band(cg_, iband_, ik_)
+     USE pwinterfacemod,    ONLY:  ngtot_g, igtomin, igtog, get_band
+     USE kinds,             ONLY:  DP     
+     INTEGER, INTENT(IN) :: iband_, ik_
+     COMPLEX(KIND=DP), INTENT(OUT) :: cg_(ngtot_g)
+
+     CALL get_band(cg_, iband_, ik_)
+  
+  END SUBROUTINE pwlib_getwfn_band
+
+  SUBROUTINE pwlib_getwfn_kpoints(klist_, weights_)
+      USE klist,           ONLY  : nkstot, xk,wk
+      USE cell_base,       ONLY  : tpiba, at
+     USE kinds,             ONLY:  DP     
+
+      REAL(DP), INTENT(OUT) :: klist_(3,nkstot), weights_(nkstot)
+      integer :: j
+    do j=1,nkstot
+      klist_(1,j)=at(1,1)*xk(1,j)+at(2,1)*xk(2,j)+at(3,1)*xk(3,j)
+      klist_(2,j)=at(1,2)*xk(1,j)+at(2,2)*xk(2,j)+at(3,2)*xk(3,j)
+      klist_(3,j)=at(1,3)*xk(1,j)+at(2,3)*xk(2,j)+at(3,3)*xk(3,j)
+      weights_(j)=wk(j)
+    end do
+!      klist_(1,:)=at(1,1)*xk(1,:)+at(2,1)*xk(2,:)+at(3,1)*xk(3,:)
+!      klist_(2,:)=at(1,2)*xk(1,:)+at(2,2)*xk(2,:)+at(3,2)*xk(3,:)
+!      klist_(3,:)=at(1,3)*xk(1,:)+at(2,3)*xk(2,:)+at(3,3)*xk(3,:)
+!      weights_=wk
+!    write(*,*)"bbbbbbbb",xk(1,:)
+  END SUBROUTINE pwlib_getwfn_kpoints
+
+!  SUBROUTINE pwlib_getwfn_orb(
+  
+  SUBROUTINE pwlib_getwfn_eigenvals(eigval_, ik)
+      USE wvfct,          ONLY  : nbnd, et
+     USE kinds,             ONLY:  DP     
+
+      REAL(DP), INTENT(OUT) :: eigval_(nbnd)
+      INTEGER, INTENT(IN) :: ik
+      eigval_(1:nbnd)=0.5*et(1:nbnd, ik)
+      
+  END SUBROUTINE pwlib_getwfn_eigenvals
+
+  SUBROUTINE pwlib_getmpifft(nnr_,mesh_)
+    USE fft_base,         ONLY : dffts, dfftp
+    INTEGER, INTENT(OUT) :: nnr_, mesh_(3)
+   
+    nnr_ = dffts%nnr
+
+    mesh_(1)=dffts%nr1x
+    mesh_(2)=dffts%nr2x
+    mesh_(3)=dffts%nr3x
+    
+
+  END SUBROUTINE pwlib_getmpifft
+!  SUBROUTINE pwlib_getfftmesh_info()
+!      USE 
+
+!  END SUBROUTINE
+
+!  SUBROUTINE pwlib_getfftmesh_data()
+!      USE
+
+!  END SUBROUTINE
+!  END SUBROUTINE pwlib_getfft_info()
+
+  
diff -urN q-e-qe-5.3/PW/src/pwlib_init.f90 q-e-qe-5.3-patched/PW/src/pwlib_init.f90
--- q-e-qe-5.3/PW/src/pwlib_init.f90	1970-01-01 01:00:00.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/pwlib_init.f90	2019-07-11 15:41:06.870591542 +0200
@@ -0,0 +1,49 @@
+!
+! Copyright (C) 2001-2013 Quantum ESPRESSO group
+! This file is distributed under the terms of the
+! GNU General Public License. See the file `License'
+! in the root directory of the present distribution,
+! or http://www.gnu.org/copyleft/gpl.txt .
+!
+!----------------------------------------------------------------------------
+SUBROUTINE pwlib_init(mpi_comm)
+  !----------------------------------------------------------------------------
+  !
+  ! ... Main program calling one instance of Plane Wave Self-Consistent Field code
+  !
+  USE environment,       ONLY : environment_start
+  USE mp_global,         ONLY : mp_startup
+  USE read_input,        ONLY : read_input_file
+  USE command_line_options, ONLY: input_file_
+  USE parallel_include   
+
+  IMPLICIT NONE
+  INTEGER :: exit_status
+  INTEGER, INTENT(IN) :: mpi_comm
+  INTEGER :: my_comm=0
+  IF(mpi_comm >= 0) THEN
+     my_comm=mpi_comm
+  ELSE
+     my_comm=MPI_COMM_WORLD
+  ENDIF
+  !
+  !
+  CALL mp_startup (my_comm)
+  !CALL mp_startup ( )
+  write(*,*) "mp_startup done"
+  CALL environment_start ( 'PWSCF' )
+  write(*,*) "environment_start done"
+  !
+  CALL read_input_file ('PW', 'scf.in' )
+  write(*,*) "input file read"
+  !
+  ! ... Perform actual calculation
+  !
+  !CALL run_pwscf  ( exit_status )
+  !
+  !CALL stop_run( exit_status )
+  !CALL do_stop( exit_status )
+  !
+  !STOP
+  !
+END SUBROUTINE pwlib_init
diff -urN q-e-qe-5.3/PW/src/pwlib_scf.f90 q-e-qe-5.3-patched/PW/src/pwlib_scf.f90
--- q-e-qe-5.3/PW/src/pwlib_scf.f90	1970-01-01 01:00:00.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/pwlib_scf.f90	2019-05-07 17:02:08.437764830 +0200
@@ -0,0 +1,37 @@
+!
+! Copyright (C) 2001-2013 Quantum ESPRESSO group
+! This file is distributed under the terms of the
+! GNU General Public License. See the file `License'
+! in the root directory of the present distribution,
+! or http://www.gnu.org/copyleft/gpl.txt .
+!
+!----------------------------------------------------------------------------
+SUBROUTINE pwlib_scf()
+  !----------------------------------------------------------------------------
+  !
+  ! ... Main program calling one instance of Plane Wave Self-Consistent Field code
+  !
+  USE environment,       ONLY : environment_start
+  USE mp_global,         ONLY : mp_startup
+  USE read_input,        ONLY : read_input_file
+  USE command_line_options, ONLY: input_file_
+  !
+  IMPLICIT NONE
+  INTEGER :: exit_status
+  !
+  !
+  !CALL mp_startup ( )
+  !CALL environment_start ( 'PWSCF' )
+  !
+  !CALL read_input_file ('PW', input_file_ )
+  !
+  ! ... Perform actual calculation
+  !
+  CALL run_pwscf  ( exit_status )
+  !
+  !CALL stop_run( exit_status )
+  !CALL do_stop( exit_status )
+  !
+  !STOP
+  !
+END SUBROUTINE pwlib_scf
diff -urN q-e-qe-5.3/PW/src/pwlib_setinfo.f90 q-e-qe-5.3-patched/PW/src/pwlib_setinfo.f90
--- q-e-qe-5.3/PW/src/pwlib_setinfo.f90	1970-01-01 01:00:00.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/pwlib_setinfo.f90	2019-07-11 14:39:22.802218753 +0200
@@ -0,0 +1,214 @@
+    !
+    !------------------------------------------------------------------------
+    !SUBROUTINE pwlib_getinfo(nat_,charge_,nup_,ndown_,nktot_,nkloc_,box_,  &
+     ! kpts_,wkp_,ngrid_,nbds_,ngridx_)
+ !   SUBROUTINE pwlib_getinfo(nat_,charge_,nup_,ndown_,nkloc_,box_,nktot_,kpts_)
+ !     !------------------------------------------------------------------------
+ !     !
+ !     USE ions_base,        ONLY : nat, nsp
+ !     USE klist,            ONLY : xk,wk,nelec,nelup,neldw,nkstot,nks,tot_charge 
+ !     USE wvfct,            ONLY : nbnd  
+!     USE fft_base,         ONLY : dffts
+!     USE cell_base,        ONLY : at,alat,tpiba
+!    USE kinds,             ONLY:  DP     
+!     !
+!     IMPLICIT NONE
+!     !
+!     !
+!     INTEGER, INTENT(OUT) :: nat_,charge_,nup_,ndown_,nktot_,nkloc_
+!     INTEGER :: jk
+!     REAL(DP), INTENT(OUT) :: box_(3,3), kpts_(3,nks) 
+!     !
+!     nat_ = nat 
+!     charge_ = tot_charge 
+!     nup_ = NINT(nelup)      
+!     ndown_ = NINT(neldw)
+!     nktot_ = nkstot
+!     nkloc_ = nks
+!     box_ = at*alat
+!
+!     kpts_(1:3,1:nks) = xk(1:3,1:nks)*tpiba
+!     
+!     ! 
+!   END SUBROUTINE pwlib_getinfo
+    !
+   SUBROUTINE pwlib_setbox_data(box_)
+     USE cell_base,       ONLY : at, alat
+     USE kinds,             ONLY:  DP     
+ 
+     IMPLICIT NONE
+     REAL(DP), INTENT(OUT) :: box_(3,3)
+     
+     box_=at*alat 
+
+   END SUBROUTINE pwlib_setbox_data
+
+   
+
+   SUBROUTINE pwlib_setatom_info(nat_, nsp_)
+      !------------------------------------------------------------------------
+      !
+      USE ions_base,       ONLY : nat, nsp
+      !
+      INTEGER, INTENT(OUT) :: nat_, nsp_
+      !
+      nat_ = nat
+      nsp_ = nsp
+
+   END SUBROUTINE pwlib_setatom_info
+
+!! Get/Set Routines for ion data.  
+   !Returns R in bohr.  
+
+!   SUBROUTINE pwlib_setatom_data(R, ityp_)
+      !------------------------------------------------------------------------
+      !
+!      USE ions_base,       ONLY : nat, nsp, ityp, tau
+!      USE cell_base,       ONLY : alat
+!     USE kinds,             ONLY:  DP     
+      !
+!      REAL(DP), INTENT(OUT) :: R(3,nat)
+!      INTEGER, INTENT(OUT) :: ityp_(nat)
+      !
+!      R     = tau*alat
+!      ityp_ = ityp
+
+!   END SUBROUTINE pwlib_setatom_data
+
+   SUBROUTINE pwlib_setatom_pos(R)
+     USE pwinterfacemod, ONLY : set_atom_pos
+     USE ions_base,  ONLY : nat
+     USE kinds,             ONLY:  DP     
+
+     REAL(DP), INTENT(OUT) :: R(3,nat)
+     !REAL, INTENT(OUT) :: R(3,nat)
+
+     CALL set_atom_pos(R)
+  
+    END SUBROUTINE pwlib_setatom_pos
+
+
+   SUBROUTINE pwlib_setatom_types(ityp_)
+     USE pwinterfacemod, ONLY : set_atom_types
+     USE ions_base,  ONLY : nat
+
+     INTEGER, INTENT(IN) :: ityp_(nat)
+
+     CALL set_atom_types(ityp_)
+
+   END SUBROUTINE pwlib_setatom_types
+  
+!   SUBROUTINE pwlib_setatom_data(R,ityp, nat_, nsp_)
+!      !------------------------------------------------------------------------
+!      USE ions_base,      ONLY nat, 
+!   END SUBROUTINE pwlib_setatom_data
+    ! anums=atomic numbers, vcharge=valence charges, masses=ion masses in amu,
+    ! names are element names.  
+   SUBROUTINE pwlib_setspecies_data(anums, vcharge, masses, names)
+      !------------------------------------------------------------------------
+      !
+      USE ions_base,       ONLY : nsp, atm, zv, amass
+     USE kinds,             ONLY:  DP     
+      !
+      INTEGER, EXTERNAL :: atomic_number
+      INTEGER, INTENT(OUT) :: anums(nsp), vcharge(nsp)
+      REAL(DP), INTENT(OUT) :: masses(nsp)
+      CHARACTER(LEN=3), INTENT(OUT) :: names(nsp)
+      INTEGER :: ik
+      !
+      do ik=1,nsp
+        anums(ik)=atomic_number(TRIM(atm(ik)))
+      end do 
+
+      vcharge = zv
+      masses=amass
+      names=atm
+      
+   END SUBROUTINE pwlib_setspecies_data
+
+  SUBROUTINE pwlib_setelectron_info(nelec_, nup_, ndown_, nktot_, nkloc_)
+      USE klist,            ONLY : nelec,nelup,neldw 
+   !   USE fft_base,         ONLY : dffts
+        
+      INTEGER, INTENT(OUT) :: nelec_, nup_, ndown_
+      
+      nelec_  = nelec 
+      nup_    = nelup
+      ndown_  = neldw
+      
+  END SUBROUTINE pwlib_setelectron_info
+ 
+!  SUBROUTINE pwlib_setwfn_info(nbands_, nktot_, nkloc_, mesh_, ngtot_, npw_, npwx_)
+!     USE pwinterfacemod,    ONLY : setwfn_info 
+!     USE mp,                ONLY : mp_rank 
+!           USE mp_world,         ONLY : world_comm
+!      USE io_global, ONLY: stdout
+!
+!     INTEGER, INTENT(OUT) :: nbands_, nktot_, nkloc_, ngtot_, npw_, npwx_
+!     INTEGER, INTENT(OUT) :: mesh_(3)
+!     
+!
+!     WRITE(*,*) 'b4 getwfn_info...'
+!          WRITE(stdout,*) 'rank = ',mp_rank(world_comm)
+!
+!     CALL setwfn_info(nbands_, nktot_, nkloc_, mesh_, ngtot_, npw_, npwx_)
+!    
+!     
+!  END SUBROUTINE pwlib_setwfn_info
+
+  SUBROUTINE pwlib_setwfn_gvecs(gvecs_)
+   USE pwinterfacemod,    ONLY: ngtot, igtog, get_gvecs
+
+   INTEGER :: gvecs_(3,ngtot)
+ 
+   CALL get_gvecs(gvecs_)
+ 
+  END SUBROUTINE pwlib_setwfn_gvecs
+
+  SUBROUTINE pwlib_setwfn_band(cg_, iband_, ik_)
+     USE pwinterfacemod,    ONLY:  ngtot_g, igtomin, igtog, get_band
+     USE kinds,             ONLY:  DP     
+     INTEGER, INTENT(IN) :: iband_, ik_
+     COMPLEX(KIND=DP), INTENT(OUT) :: cg_(ngtot_g)
+
+     CALL get_band(cg_, iband_, ik_)
+  
+  END SUBROUTINE pwlib_setwfn_band
+
+  SUBROUTINE pwlib_setwfn_kpoints(klist_, weights_)
+      USE klist,           ONLY  : nkstot, xk,wk
+      USE cell_base,       ONLY  : tpiba, at
+     USE kinds,             ONLY:  DP     
+
+      REAL(DP), INTENT(OUT) :: klist_(3,nkstot), weights_(nkstot)
+      klist_(1,:)=at(1,1)*xk(1,:)+at(2,1)*xk(2,:)+at(3,1)*xk(3,:)
+      klist_(2,:)=at(1,2)*xk(1,:)+at(2,2)*xk(2,:)+at(3,2)*xk(3,:)
+      klist_(3,:)=at(1,3)*xk(1,:)+at(2,3)*xk(2,:)+at(3,3)*xk(3,:)
+      weights_=wk
+
+  END SUBROUTINE pwlib_setwfn_kpoints
+  
+  SUBROUTINE pwlib_setwfn_eigenvals(eigval_, ik)
+      USE wvfct,          ONLY  : nbnd, et
+     USE kinds,             ONLY:  DP     
+
+      REAL(DP), INTENT(OUT) :: eigval_(nbnd)
+      INTEGER, INTENT(IN) :: ik
+      eigval_(1:nbnd)=0.5*et(1:nbnd, ik)
+      
+  END SUBROUTINE pwlib_setwfn_eigenvals
+
+  SUBROUTINE pwlib_setmpifft(nnr_,mesh_)
+    USE fft_base,         ONLY : dffts, dfftp
+    INTEGER, INTENT(OUT) :: nnr_, mesh_(3)
+   
+    nnr_ = dffts%nnr
+
+    mesh_(1)=dffts%nr1x
+    mesh_(2)=dffts%nr2x
+    mesh_(3)=dffts%nr3x
+    
+
+  END SUBROUTINE pwlib_setmpifft
+
+  
diff -urN q-e-qe-5.3/PW/src/read_file.f90 q-e-qe-5.3-patched/PW/src/read_file.f90
--- q-e-qe-5.3/PW/src/read_file.f90	2016-01-08 16:25:24.000000000 +0100
+++ q-e-qe-5.3-patched/PW/src/read_file.f90	2019-07-11 14:46:13.064051617 +0200
@@ -177,6 +177,7 @@
   ! ... allocation
   !
   ALLOCATE( ityp( nat ) )
+  write(*,*)'allocating tau now!'
   ALLOCATE( tau(    3, nat ) )
   ALLOCATE( if_pos( 3, nat ) )
   ALLOCATE( force(  3, nat ) )
